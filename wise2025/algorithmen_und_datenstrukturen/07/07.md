# Algorithmen und Datenstrukturen - Übungsblatt 7

## Aufgabe 7.1: Einfügen in binäre Suchbäume

**Eingabefolge:** `30, 40, 24, 58, 48, 26, 11, 13`

### Resultierende Baumstruktur

Wir fügen die Elemente schrittweise ein.
Regel: Kleineres nach links, Größeres nach rechts.

```text
       30
      /  \
    24    40
   /  \     \
 11    26    58
   \        /
   13      48
```

### Traversierungen

1.  **Pre-Order (Hauptreihenfolge):** `Vater -> Links -> Rechts`
    - **Ergebnis:** `30, 24, 11, 13, 26, 40, 58, 48`

2.  **Post-Order (Nebenreihenfolge):** `Links -> Rechts -> Vater`
    - **Ergebnis:** `13, 11, 26, 24, 48, 58, 40, 30`

3.  **In-Order (Symmetrische Reihenfolge):** `Links -> Vater -> Rechts`
    - **Ergebnis:** `11, 13, 24, 26, 30, 40, 48, 58`

**Was fällt auf?**
Die In-Order-Traversierung eines binären Suchbaums liefert die Schlüssel immer in **aufsteigend sortierter Reihenfolge**.

## Aufgabe 7.2: Suchen nach minimalen Schlüsseln (Ceiling)

### Algorithmus (Idee)

Wir suchen im die "Ceiling"-Funktion im Baum.

1.  Starte an der Wurzel.
2.  Initialisiere `candidate = null`.
3.  Solange der aktuelle Knoten nicht null ist:
    - Ist der Knotenschlüssel **gleich** `k`: Wir haben den exakten Wert gefunden. Rückgabe: `k`
    - Ist der Knotenschlüssel **kleiner** als `k`: Dieser Knoten (und sein linker Teilbaum) sind zu klein. Wir müssen **rechts** weitersuchen
    - Ist der Knotenschlüssel **größer** als `k`: Dieser Knoten ist ein potenzieller Kandidat! Aber vielleicht gibt es im linken Teilbaum noch einen Wert, der kleiner ist als der aktuelle Knoten, aber immer noch `>= k`. Wir merken uns den aktuellen Knoten als `candidate` und suchen **links** weiter
4.  Wenn die Schleife endet, geben wir `candidate` zurück (oder null, falls nichts gefunden wurde)

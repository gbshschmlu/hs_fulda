# Übungsblatt 2

## 2.1 Binäre Exponentiation (Verifikation)

### Was macht der Algorithmus?

Der Algorithmus berechnet 2^n. Statt n-mal zu multiplizieren, nutzt er binäre Exponentiation. Das ist deutlich schneller: O(log n) statt O(n).

### Wie funktioniert der Beweis?

**Schleifeninvariante:** `z * x^y = 2^n` und `y >= 0`

**Initialisierung:**

- Start: z=1, x=2, y=n
- Check: `1 * 2^n = 2^n` und `y=n >= 0`

**Erhaltung in der Schleife:**

- **Ungerades y:** Wir setzen `z = z*x` und `y = y-1`
    - Vorher: `z * x^y`
    - Nachher: `(z*x) * x^(y-1) = z * x^y`

- **Gerades y:** Wir setzen `x = x*x` und `y = y/2`
    - Vorher: `z * x^y`
    - Nachher: `z * (x*x)^(y/2) = z * x^y`

**Terminierung:**

- Schleife stoppt bei y=0
- Dann gilt: `z * x^0 = z * 1 = z = 2^n`

### Warum hält der Algorithmus?

Die Variable y wird in jedem Durchlauf kleiner (entweder -1 oder halbiert). Da y >= 0 bleibt, erreichen wir garantiert y=0. Keine Endlosschleife möglich.

---

## 2.2 Halteproblem

### Der Beweis (Widerspruchsbeweis)

**Annahme:** Es gibt eine magische Funktion `terminates(P, I)`, die für jedes Programm P mit Input I sagen kann, ob es stoppt oder nicht.

**Konstruktion eines Paradoxons:**

```
function paradox(P):
    if terminates(P, P) == true:
        while true:  // Endlosschleife
            pass
    else:
        return  // Stopp sofort
```

**Der Widerspruch:** Was passiert bei `paradox(paradox)`?

- Wenn paradox(paradox) stoppt → terminates gibt true → paradox geht in Endlosschleife → paradox stoppt NICHT
- Wenn paradox(paradox) nicht stoppt → terminates gibt false → paradox stoppt sofort → paradox STOPPT

Wir haben einen logischen Widerspruch, also muss die Annahme falsch sein.

### Warum das Bild der Fee?

Die "Fee" ist eine Metapher für eine allwissende, magische Funktion. Der Beweis zeigt: Selbst wenn wir uns eine solche Fee vorstellen, führt ihre Existenz zu logischen Widersprüchen. Sie KANN nicht existieren - nicht weil wir sie nicht programmieren können, sondern weil sie logisch unmöglich ist.

### Allgemeingültigkeit

Der Beweis gilt für alle Turing-vollständigen Systeme (also praktisch alle modernen Programmiersprachen).

---

## 2.3 Insertion Sort - Benchmarks

### Messergebnisse

```
n=1000:  worst=3.821ms  | best=0.005ms
n=2000:  worst=1.401ms  | best=0.007ms
n=5000:  worst=8.651ms  | best=0.012ms
n=10000: worst=34.331ms | best=0.021ms
```

### Analyse

**Worst Case (absteigend sortiert):**

- Laufzeit wächst quadratisch → O(n²)
- Von n=1000 auf n=10000 (Faktor 10) steigt die Zeit um ~Faktor 9 (von 3.8ms auf 34.3ms)
- Macht Sinn: Bei jedem neuen Element müssen alle vorherigen verschoben werden

**Best Case (schon sortiert):**

- Laufzeit wächst linear → O(n)
- Bleibt sehr schnell, weil pro Element nur 1 Vergleich nötig ist
- Keine Verschiebungen notwendig

Die Messungen passen perfekt zur Theorie!

---

## 2.4 Merge Sort - Schritt für Schritt

**Start:** `[31, 41, 59, 26, 41, 58, 1, 12, 43]`

### Phase 1: Teilen (Divide)

```
[31, 41, 59, 26, 41, 58, 1, 12, 43]
              ↓
    [31, 41, 59, 26] | [41, 58, 1, 12, 43]
              ↓
  [31, 41] [59, 26] | [41, 58] [1, 12, 43]
              ↓
[31] [41] [59] [26] | [41] [58] [1] [12, 43]
                                        ↓
                                    [12] [43]
```

### Phase 2: Verschmelzen (Merge)

```
[31] [41] [59] [26] | [41] [58] [1] [12] [43]
        ↓
  [31, 41] [26, 59] | [41, 58] [1] [12, 43]
        ↓
[26, 31, 41, 59] | [41, 58] [1, 12, 43]
        ↓
[26, 31, 41, 59] | [1, 12, 41, 43, 58]
        ↓
  [1, 12, 26, 31, 41, 41, 43, 58, 59]
```

**Endergebnis:** `[1, 12, 26, 31, 41, 41, 43, 58, 59]`

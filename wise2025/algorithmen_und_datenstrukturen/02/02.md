# Übungsblatt 2

## Aufgabe 2.1 (Verifikation)

*   **Problem:** Der Algorithmus berechnet `2^n` mittels binärer Exponentiation.
*   **Vorteil:** Bessere Laufzeitkomplexität von **O(log n)** im Vergleich zur naiven Implementierung mit O(n).
*   **Partielle Korrektheit (Nachweis mit Invariante `P: z * x^y = 2^n ∧ y >= 0`):**
    *   **Initialisierung:** Vor der Schleife gilt `1 * 2^n = 2^n` und `y = n >= 0`. `P` ist wahr.
    *   **Erhaltung:** Angenommen `P` gilt.
        *   Fall `y` ungerade: `(z*x) * x^(y-1) = z * x^y = 2^n`. `P` bleibt gültig.
        *   Fall `y` gerade: `z * (x*x)^(y/2) = z * x^y = 2^n`. `P` bleibt gültig.
    *   **Terminierung:** Die Schleife endet bei `y=0`. Aus `P` folgt `z * x^0 = 2^n`, also `z = 2^n`. Dies ist das korrekte Ergebnis.
*   **Totale Korrektheit (Terminierung):** Die Variable `y` wird in jedem Schritt durch `y-1` oder `y/2` streng dekrementiert und erreicht somit garantiert den Wert 0. Der Algorithmus hält immer an.

## Aufgabe 2.2 (Halteproblem)

*   **Beweis (durch Widerspruch):**
    *   **Annahme:** Es existiert eine Funktion `terminates(P, I)`, die für jedes Programm `P` mit Input `I` entscheidet, ob es hält.
    *   **Konstruktion:** Baue ein Programm `paradox(P)`, das `terminates(P, P)` aufruft.
        *   Wenn `terminates` `true` liefert -> Endlosschleife.
        *   Wenn `terminates` `false` liefert -> Programm hält an.
    *   **Widerspruch:** Was passiert bei `paradox(paradox)`?
        *   Wenn `paradox(paradox)` hält, muss `terminates` `true` liefern, was `paradox` in eine Endlosschleife schickt.
        *   Wenn `paradox(paradox)` nicht hält, muss `terminates` `false` liefern, was `paradox` sofort anhalten lässt.
    *   **Schlussfolgerung:** Die Annahme ist falsch. Eine solche Funktion `terminates` kann nicht existieren.
*   **Bild der Fee:** Eine Metapher für eine "magische", allwissende Funktion, deren Existenz logisch unmöglich ist.
*   **Allgemeingültigkeit:** Ja, der Beweis gilt für alle Turing-vollständigen Berechnungsmodelle (d.h. für alle gängigen Programmiersprachen).

## Aufgabe 2.3 (Insertion Sort)

### Ausgabe der Java-Datei:
```text
=== Aufgabe 2.3: Laufzeitmessungen INSERTION SORT ===

Insertion Sort (n=1000, worst case): 3.821 ms
Insertion Sort (n=1000, best case): 0.005 ms

Insertion Sort (n=2000, worst case): 1.401 ms
Insertion Sort (n=2000, best case): 0.007 ms

Insertion Sort (n=5000, worst case): 8.651 ms
Insertion Sort (n=5000, best case): 0.012 ms

Insertion Sort (n=10000, worst case): 34.331 ms
Insertion Sort (n=10000, best case): 0.021 ms
```

### Analyse:
*   Die Ergebnisse entsprechen den Erwartungen
*   **Worst Case:** Die Laufzeit steigt quadratisch (O(n²)), was am Anstieg der Millisekunden ersichtlich ist
*   **Best Case:** Die Laufzeit ist sehr gering und steigt linear (O(n))

## Aufgabe 2.4 (Merge Sort Manuell)

**Array A = `[31, 41, 59, 26, 41, 58, 1, 12, 43]`**

1.  **Divide (Teilen):**
    *   `[31, 41, 59, 26, 41, 58, 1, 12, 43]`
    *   `[31, 41, 59, 26]` | `[41, 58, 1, 12, 43]`
    *   `[31, 41]` | `[59, 26]` | `[41, 58]` | `[1, 12, 43]`
    *   `[31]` | `[41]` | `[59]` | `[26]` | `[41]` | `[58]` | `[1]` | `[12, 43]`
    *   `[12]` | `[43]`

2.  **Conquer (Zusammenfügen und Sortieren):**
    *   `[31, 41]` | `[26, 59]` | `[41, 58]` | `[1]` | `[12, 43]`
    *   `[26, 31, 41, 59]` | `[1, 12, 43]` | `[41, 58]`
    *   `[26, 31, 41, 59]` | `[1, 12, 41, 43, 58]`
    *   `[1, 12, 26, 31, 41, 41, 43, 58, 59]`

**Endergebnis: `[1, 12, 26, 31, 41, 41, 43, 58, 59]`**

# Algorithmen und Datenstrukturen - Übungsblatt 5

## Aufgabe 5.1: Queue (Verkettete Liste)

In dieser Aufgabe wurde der **ADT Queue** (Warteschlange) implementiert. Anstatt eines Arrays wird hier eine **verkettete Liste** verwendet.

### Funktionsweise

- **FIFO-Prinzip (First-In, First-Out):** Wer zuerst kommt, mahlt zuerst.
- **Interne Struktur:**
    - Die Queue hält zwei Referenzen: `first` (Anfang der Schlange) und `last` (Ende der Schlange).
    - Jeder Eintrag ist ein `QueueNode`, der den Wert (`data`) und einen Zeiger auf den Nachfolger (`next`) enthält.
- **Operationen:**
    - `enqueue(T item)`: Fügt ein Element hinten an (`last.next`). Laufzeit: O(1).
    - `dequeue()`: Nimmt das Element von vorne weg (`first`). Laufzeit: O(1).

### Beobachtungen / Notizen für die Vorstellung

- **Vorteil gegenüber Array:** Die Queue ist dynamisch. Wir laufen nie in ein "Queue full" Problem (außer der RAM ist voll), und wir müssen kein Array kopieren/vergrößern.
- **Implementierung:** Zeige kurz die `enqueue` Methode. Wichtig ist der Sonderfall: Wenn die Queue leer ist, muss `first` auch auf den neuen Knoten zeigen. Ansonsten hängen wir es nur an `last` an und verschieben den `last`-Zeiger.

---

## Aufgabe 5.2: Stack (Klammer-Check)

Hier wird ein **Stack** verwendet, um die syntaktische Korrektheit von Klammerungen zu prüfen. Dies ist ein klassischer Anwendungsfall für Stacks (wird z.B. auch von Compilern genutzt).

### Algorithmus

1. Wir laufen Zeichen für Zeichen durch den String.
2. **Öffnende Klammer** (`(`, `[`, `{`): Wird auf den Stack gepusht (oben draufgelegt). Wir merken uns: "Da wurde etwas geöffnet, das noch geschlossen werden muss".
3. **Schließende Klammer** (`)`, `]`, `}`):
    - Ist der Stack leer? -> Fehler (Klammer geschlossen, die nie geöffnet wurde).
    - Wir nehmen das oberste Element vom Stack (`pop`).
    - Passt das Paar nicht zusammen (z.B. `{` und `]`)? -> Fehler.
4. **Am Ende:** Ist der Stack leer? Wenn nein -> Fehler (es sind noch Klammern offen).

### Beobachtungen / Notizen für die Vorstellung

- **LIFO-Prinzip (Last-In, First-Out):** Die zuletzt geöffnete Klammer muss als erstes wieder geschlossen werden. Genau das bildet der Stack ab.
- **Gültigkeit:**
    - `{x[(a)b]}` ist gültig. Der Stack wächst: `{`, `[`, `(`. Dann wird abgebaut.
    - `{a(b)x[d]` ist ungültig. Am Ende bleibt die `{` auf dem Stack liegen.
- **Java API:** Ich habe `java.util.ArrayDeque` verwendet, da die Klasse `Stack` in Java veraltet ist, aber das Prinzip ist identisch (`push`/`pop`).

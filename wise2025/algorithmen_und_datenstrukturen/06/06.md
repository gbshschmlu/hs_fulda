# Algorithmen und Datenstrukturen - Übungsblatt 6

## Aufgabe 6.1: Nullen und Neunen (Queue / BFS)

**Ziel:** Finde die kleinste Zahl $X$, die nur aus Ziffern `0` und `9` besteht und durch $N$ teilbar ist.

### Idee & Konzept

Wir bauen einen **Baum** aus Zahlen auf und suchen mittels **Breitensuche (BFS)**. Da eine Queue für BFS genutzt wird, finden wir automatisch die Zahl mit den wenigsten Stellen (und dem kleinsten Wert) zuerst.

**Ablauf (Visualisierung an der Tafel):**

1. Start mit Queue: `["9"]`
2. **Entnehme "9"**:
    - Ist `9 % N == 0`? Wenn ja -> Fertig.
    - Wenn nein -> Generiere Kinder: Hänge "0" und "9" an.
    - Füge zur Queue hinzu: `["90", "99"]`
3. **Entnehme "90"**:
    - Testen...
    - Kinder erzeugen: `["99", "900", "909"]`

**Warum funktioniert das?**
Wir testen die Zahlen der Größe nach: 9, 90, 99, 900, 909, 990, 999...
Die erste Zahl, die den Test besteht, ist garantiert die kleinste.

---

## Aufgabe 6.2: Fibonacci-Folge (Queue als Fenster)

**Formel:** $f(n) = f(n-1) + f(n-2)$

### Implementierung mit Queue

Statt Rekursion oder Array nutzen wir eine Queue der Größe 2 als "schiebendes Fenster".

**Beispiel für n=5:**

1. **Init:** Queue = `[1, 1]` (entspricht f(1), f(2))
2. **Schritt 3:**
    - `remove()` -> 1 (f_alt)
    - `peek()` -> 1 (f_neu)
    - `sum` = 1 + 1 = 2
    - `add(2)`
    - Queue jetzt: `[1, 2]`
3. **Schritt 4:**
    - `remove()` -> 1
    - `peek()` -> 2
    - `sum` = 1 + 2 = 3
    - `add(3)`
    - Queue jetzt: `[2, 3]`
4. **Schritt 5:**
    - `remove()` -> 2
    - `peek()` -> 3
    - `sum` = 2 + 3 = 5
    - `add(5)`
    - Queue jetzt: `[3, 5]`

**Ergebnis:** Das letzte Element in der Queue.

---

## Aufgabe 6.3: Offenes Hashing (Verkettung)

Hier bedeutet "Offenes Hashing" (nach Skript-Terminologie oft "Hashing mit Verkettung/Chaining"), dass mehrere Elemente im selben Slot als Liste gespeichert werden.

**Hashfunktion:**
$f(s) = (\text{AnzahlVokale}(s) + \text{Zeichen}(s)) \mod 8$

### Manuelle Rechnung

| Name          |   Vokale    | Länge | Rechnung             | Hash  |
| :------------ | :---------: | :---: | :------------------- | :---: |
| **Patrizia**  | 4 (a,i,i,a) |   8   | (4 + 8) % 8 = 12 % 8 | **4** |
| **Sebastian** | 4 (e,a,i,a) |   9   | (4 + 9) % 8 = 13 % 8 | **5** |
| **Maike**     |  3 (a,i,e)  |   5   | (3 + 5) % 8 = 8 % 8  | **0** |
| **Lukas**     |   2 (u,a)   |   5   | (2 + 5) % 8 = 7 % 8  | **7** |
| **Nele**      |   2 (e,e)   |   4   | (2 + 4) % 8 = 6 % 8  | **6** |
| **Sarah**     |   2 (a,a)   |   5   | (2 + 5) % 8 = 7 % 8  | **7** |
| **Matthias**  |  3 (a,i,a)  |   8   | (3 + 8) % 8 = 11 % 8 | **3** |
| **Manuel**    |  3 (a,u,e)  |   6   | (3 + 6) % 8 = 9 % 8  | **1** |

**Kollisionen:**

- Lukas (7) und Sarah (7) kollidieren. Sarah wird in die Liste bei Index 7 hinter Lukas angehängt.

**Finale Tabelle:**
0: [Maike]
1: [Manuel]
2: []
3: [Matthias]
4: [Patrizia]
5: [Sebastian]
6: [Nele]
7: [Lukas, Sarah]

---

## Aufgabe 6.4: Geschlossenes Hashing (Sondieren)

Hier bedeutet "Geschlossenes Hashing" (im Skript vermutlich "Offene Adressierung"), dass alle Elemente direkt in der Tabelle der Größe $N=10$ landen. Bei Kollision suchen wir einen neuen Platz.

**Hashfunktion:** $f(x) = \lfloor x/100 \rfloor \mod 10$ (Hunderterstelle)

### 1. Lineares Sondieren (+1, +2, ...)

| Schlüssel | $f(x)$ | Sondierung                                             | Platz |
| :-------- | :----: | :----------------------------------------------------- | :---: |
| 1001      |   0    | Frei                                                   |   0   |
| 1542      |   5    | Frei                                                   |   5   |
| 429       |   4    | Frei                                                   |   4   |
| 1320      |   3    | Frei                                                   |   3   |
| 17        |   0    | Besetzt (1001) -> +1 -> 1 Frei                         |   1   |
| 900       |   9    | Frei                                                   |   9   |
| 417       |   4    | Besetzt (429) -> +1 -> Besetzt (1542) -> +1 -> 6 Frei  |   6   |
| 2302      |   3    | Besetzt (1320) -> +1 -> Besetzt (429) -> ... -> 7 Frei |   7   |
| 1920      |   9    | Besetzt (900) -> +1 -> Besetzt (1001) -> ... -> 2 Frei |   2   |

**Tabelle:** `[1001, 17, 1920, 1320, 429, 1542, 417, 2302, _, 900]`

### 2. Quadratisches Sondieren (+1², +2², +3²...)

Formel: $idx = (Home + i^2) \mod 10$

| Schlüssel | $f(x)$ | Sondierung                                                                                                                                                 |  Platz   |
| :-------- | :----: | :--------------------------------------------------------------------------------------------------------------------------------------------------------- | :------: |
| 1001      |   0    | Frei                                                                                                                                                       |    0     |
| 1542      |   5    | Frei                                                                                                                                                       |    5     |
| 429       |   4    | Frei                                                                                                                                                       |    4     |
| 1320      |   3    | Frei                                                                                                                                                       |    3     |
| 17        |   0    | Besetzt -> $0+1^2=1$ (Frei)                                                                                                                                |    1     |
| 900       |   9    | Frei                                                                                                                                                       |    9     |
| 417       |   4    | Besetzt -> $4+1^2=5$ (Besetzt) -> $4+2^2=8$ (Frei)                                                                                                         |    8     |
| 2302      |   3    | Besetzt -> $3+1^2=4$ (Besetzt) -> $3+2^2=7$ (Frei)                                                                                                         |    7     |
| 1920      |   9    | Besetzt -> $9+1^2=0$ (Besetzt) -> $9+2^2=13 \to 3$ (Besetzt) -> $9+3^2=18 \to 8$ (Besetzt) -> $9+4^2=25 \to 5$ (Besetzt) -> $9+5^2=34 \to 4$ (Besetzt) ... | **FAIL** |

**Was passiert? (Die Beobachtung)**
Der Schlüssel **1920** kann nicht eingefügt werden!
Beim quadratischen Sondieren werden (bei Tabellengröße die keine Primzahl ist oder bestimmte Bedingungen nicht erfüllt) nicht immer alle freien Plätze erreicht. Wir laufen hier in einen Zyklus oder treffen nur besetzte Felder, obwohl Feld 2 und 6 noch frei wären. Das nennt man **sekundäres Clustering** bzw. das Problem, dass die Sondierungsfolge nicht den ganzen Raum abdeckt.
